# 優化 daily-digest-prompt：Todoist × Claude Code 自主任務執行

**AI 驅動的 Todoist 任務自動化生態系統正快速成熟。** Doist 官方的 `todoist-ai` MCP 伺服器，結合 Claude Code 的 skill 系統以及新興的 cron 排程代理調度器，創造了一個可行的架構來讀取 Todoist 任務並自主完成它們。GitHub 上超過 80 個相關專案中，最有效的模式是三層架構：**排程守護程序**（cron/heartbeat）觸發**帶有任務專屬 skill 的 Claude Code**，再透過 **MCP 連接 Todoist** 來讀取、執行和關閉任務。

-----

## 一、官方 Todoist-AI 橋接器改變了一切

對這個系統來說最重要的專案是 **[Doist/todoist-ai](https://github.com/Doist/todoist-ai)**（206 星，持續維護中）。這是 Doist 官方函式庫，將 Todoist 工具暴露給任何 AI 代理。它以 MCP 伺服器形式運行在 `https://ai.todoist.net/mcp`，支援 Streamable HTTP 傳輸和 OAuth 認證。`findTasksByDate` 和 `addTasks` 等工具是**框架無關的**——可透過 MCP 使用，也可直接透過 Vercel AI SDK 匯入自訂程式碼。設定只需一行指令：

```
claude mcp add --transport http todoist https://ai.todoist.net/mcp
```

社群已建立至少 **10 個額外的 Todoist MCP 伺服器**，各有獨特優勢：

|專案                                                                                       |特色                                                            |
|-----------------------------------------------------------------------------------------|--------------------------------------------------------------|
|**[greirson/mcp-todoist](https://github.com/greirson/mcp-todoist)**                      |**Dry-run 模式**（`DRYRUN=true`），可在不修改真實任務的情況下驗證操作——對安全測試自主執行至關重要|
|**[kydycode/todoist-mcp-server-ext](https://github.com/kydycode/todoist-mcp-server-ext)**|透過 Todoist 篩選器引擎進行關鍵字搜尋、語義任務移動、已完成任務歷史（via Sync API）及批次操作     |
|**[Hint-Services/mcp-todoist](https://github.com/Hint-Services/mcp-todoist)**            |橫跨 4 大類別的 15 個工具，含 Zod 驗證和批次操作                                |

**最佳 MCP 選擇建議：**

- 官方 `todoist-ai`：適合生產環境的可靠性和 OAuth
- `greirson/mcp-todoist`：適合開發和測試（dry-run 模式）
- `kydycode` 擴展版：適合進階篩選和搜尋

-----

## 二、Skill 驅動的任務執行已有明確典範模式

Claude Code 的 skill 系統是將 Todoist 任務描述轉化為已完成工作的執行引擎。**[anthropics/skills](https://github.com/anthropics/skills)** 官方儲存庫定義了 SKILL.md 的標準結構：YAML 前置資料（名稱、描述）加上 Markdown 指令，並配備 `scripts/`、`references/` 和 `assets/` 子目錄。Skill 使用**漸進式揭露**——元資料掃描約 100 tokens，完整內容在 5k tokens 以下，捆綁資源僅在需要時載入。這對處理多任務的每日摘要系統很重要，因為上下文視窗是共享資源。

### 三大關鍵 Skill 框架

**1. [obra/superpowers](https://github.com/obra/superpowers)（40,900 星）**

最具影響力的 skill 框架。實現了子代理驅動的開發方法論：腦力激盪 → 撰寫計劃 → 使用 git worktree → 子代理執行。Skill 根據上下文匹配自動調用。其 writing-plans skill 將工作分解為 **2-5 分鐘的小型任務**，直接對應 Todoist 子任務分解。對於複雜任務，這種「先規劃再執行」的模式可防止 AI 在自主操作期間偏離目標。

**2. [levnikolaevich/claude-code-skills](https://github.com/levnikolaevich/claude-code-skills)**

提供最完整的 skill 驅動敏捷工作流程自動化範例。使用**編號層級體系**（ln-XXX 命名）：

```
研究 (001-002) → 文件 (1XX) → 規劃 (2XX) → Story 執行 (4XX) → 程式碼審計 (6XX)
```

協調器 skill 如 `ln-100-documents-pipeline` 自動委派給子 skill。`ln-400-story-executor` 以品質閘門自動執行 Story 至 Done 狀態。這個模式——**協調器 skill 委派給專門子 skill 並設定驗證檢查點**——正是任務到 skill 路由應複製的架構。

**3. [daymade/claude-code-skills](https://github.com/daymade/claude-code-skills)**

包含 `ccpm`（Claude Code Plugin Manager），可程式化搜尋、安裝和管理 skill。

Skill 目錄資源：**[travisvn/awesome-claude-skills](https://github.com/travisvn/awesome-claude-skills)** 和 **VoltAgent/awesome-agent-skills**（來自官方開發團隊的 300+ skill）。

-----

## 三、七種每日任務執行排程架構

每日摘要系統——排程讀取待辦 Todoist 任務並路由至 Claude Code skill——已有多個可投入生產的實作方案。以下按成熟度排名：

### 1. HEARTBEAT.md 守護程序 — [t0dorakis/murmur](https://github.com/t0dorakis/murmur)

最優雅的模式。將排程定義為帶 YAML 前置資料的 Markdown 檔案（`interval: 30m` 或 `cron: "0 9 * * *"`），守護程序自動發現 heartbeat 並按排程調用 Claude Code CLI。錯過的執行會合併為一次補執行。**與 daily-digest-prompt 架構最為匹配。**

### 2. Go 語言 TUI 排程器 — [kylemclaren/claude-tasks](https://github.com/kylemclaren/claude-tasks)

專為排程 Claude Code 任務而建，支援秒級精度的 cron 表達式。包含**使用量閾值管理**（預設 80%），API 配額不足時自動跳過任務——對防止任務中斷至關重要。結果報告至 Discord/Slack。

### 3. Claude Code 原生外掛 — [jshchnz/claude-code-scheduler](https://github.com/jshchnz/claude-code-scheduler)

作為 Claude Code 外掛安裝。使用者透過自然對話建立排程任務：「每個工作日上午 9 點排程一次程式碼審查」→ Claude 生成 cron 設定 JSON。支援 git worktree 隔離以安全執行。

### 4. MCP API 排程器 — [tonybentley/claude-mcp-scheduler](https://github.com/tonybentley/claude-mcp-scheduler)

設定驅動的系統，在 cron 間隔直接呼叫 Anthropic API（非 CLI）並使用 MCP 工具。輸出儲存為帶時間戳的檔案。專為**無頭伺服器、VM 和容器**設計——適合伺服器端生產部署。

### 5. Markdown 定義的代理 — [agentuse/agentuse](https://github.com/agentuse/agentuse)（約 110 星）

將代理定義為 `.agentuse` 檔案，前置資料包含模型、排程、MCP 伺服器和環境變數。同時支援 cron 和 webhook 觸發，可讓 Todoist webhook 觸發代理執行。支援子代理組合以處理複雜工作流程。

### 6. 24/7 Slack 守護程序 — [context-machine-lab/sleepless-agent](https://github.com/context-machine-lab/sleepless-agent)

透過 Slack 最大化 Claude Code Pro 使用量的守護程序。任務佇列由 SQLite 支撐，每個任務有隔離工作區，自動 Git 提交和 PR。實現**日夜使用量閾值**（白天 20%，夜間 80%）以優化成本。

### 7. AWS 多代理編排器 — [awslabs/cli-agent-orchestrator](https://github.com/awslabs/cli-agent-orchestrator)

企業級系統，使用 tmux session 搭配「Flows」——在 Markdown 中以 YAML 前置資料定義排程代理會話。監督代理協調專門工作者。多代理每日自動化的最穩健方案。

-----

## 四、任務到 Skill 的路由模式

核心挑戰——讀取任務描述並決定執行哪個 skill——在自主代理領域已是已解決的問題。研究中浮現五種路由模式：

### 1. LLM 語義路由（最靈活）

[CrewAI](https://github.com/crewAIInc/crewAI) 和 [AWS Agent Squad](https://github.com/awslabs/agent-squad) 使用分類器分析任務描述，結合代理特性和對話歷史選擇最佳處理者。**[fast-agent](https://github.com/evalstate/fast-agent)** 以 `@fast.router` 和 `@fast.orchestrator` 裝飾器實現此功能。

### 2. 模板路由（更簡單、更確定性）

**[TSK](https://github.com/dtormoen/tsk)**（111 星）使用 `--type feat/doc/etc.` 旗標映射到預定義提示模板。對於每日摘要系統，Todoist 標籤如 `@code`、`@research`、`@write` 可直接映射到 Claude Code skill 檔案。

### 3. ReAct 代理模式

**[j0rd1smit/todoist_react_agent](https://github.com/j0rd1smit/todoist_react_agent)** 展示 THOUGHT → ACTION → OBSERVATION → FINAL ANSWER 迴圈直接操作 Todoist 任務，包含錯誤恢復和透過次級 LLM 呼叫的 **JSON 修復**。

### 4. TaskSense AI 引擎（最直接適用）

**[ashwinma14/todoist-ai-assistant](https://github.com/ashwinma14/todoist-ai-assistant)** 使用語義分析分配標籤，帶有**信心分數和解釋**、模式感知優先排序（工作、個人、週末）和可配置推理深度。

管線模式：`任務內容 → 語義分析 → 標籤分配 → 區段路由 → 優先級排名`

可改造為路由任務到特定 Claude Code skill 而非 Todoist 區段。

### 5. 標籤驅動路由（適合 daily-digest-prompt）

結合以上模式，使用 Todoist 標籤作為 skill 識別符：

```
@code → code-generation/SKILL.md
@research → deep-research/SKILL.md
@write → writing/SKILL.md
```

無標籤任務則回退到 LLM 語義路由。

-----

## 五、錯誤處理、驗證與重試機制

生產級自主系統需要穩健的失敗管理。研究中最有效的模式：

### 反壓閘門

[Ralph Orchestrator](https://github.com/mikeyobrien/ralph-orchestrator) 拒絕不完整的工作——測試、lint 和型別檢查必須通過，代理才能宣告任務完成。代理以 `LOOP_COMPLETE` token 明確發出完成信號；若無此信號，系統會繼續迭代。

### 沙箱執行

[TSK](https://github.com/dtormoen/tsk)、OpenHands 和 SWE-agent 都使用 Docker 容器隔離。TSK 額外添加 Squid 正向代理以控制每個容器的網路存取。對於每日摘要系統，在隔離環境中執行每個任務的 Claude Code 會話，可防止一個失敗任務影響後續任務。

### 全新上下文恢復

Ralph Orchestrator 的哲學主張：任務失敗時，啟動全新會話而非嘗試修復損壞的狀態。這與 Claude Code 的會話模型一致——每次 `-p` 調用都從乾淨狀態開始。

### 速率限制感知

[Ralphy](https://github.com/michaelshimeles/ralphy) 偵測速率限制和配額錯誤，延遲受影響的任務以待重試。[claude-tasks](https://github.com/kylemclaren/claude-tasks) 實現使用量閾值（預設 **80%**），API 配額不足時自動跳過任務。

### Git 驗證

[Aider](https://github.com/Aider-AI/aider)（40,500 星）自動提交每次變更並附帶合理的提交訊息，提供內建的復原能力。[TSK](https://github.com/dtormoen/tsk) 返回 git 分支供人工審查。每個完成的任務應產生可驗證的成果——一個 commit、一個檔案、一個 PR——在 Todoist 任務標記完成前可供檢查。

-----

## 六、n8n 橋接器連接 Todoist Webhook 到 Claude Code

### SSH 方案

**[theNetworkChuck/n8n-claude-code-guide](https://github.com/theNetworkChuck/n8n-claude-code-guide)** 是參考實作。模式：n8n 觸發器 → SSH 節點 → 運行 Claude Code CLI 的 Linux 伺服器。跨多步工作流程的會話連續性使用基於 UUID 的 session ID 搭配 `-r` 旗標恢復。

### 原生整合方案

**[n8n-nodes-claudecode](https://github.com/johnlindquist/n8n-nodes-claudecode)** 是社群節點，直接包裝 Claude Code SDK，消除 SSH 層。

預建工作流程模式：

```
Webhook (GitHub Issue) → Claude Code → 建立 PR → 通知 Slack
支援工單 → Claude Code → 重現 → 修復 → 測試 → 部署 → 自動回覆
```

對於每日摘要系統的模式：

```
Todoist Webhook → n8n → Claude Code → 執行 Skill → 完成 Todoist 任務 → 報告至 Slack
```

### 自我改進系統

**[czlonkowski/n8n-mcp](https://github.com/czlonkowski/n8n-mcp)** 讓 Claude 深入了解 n8n 的 1,084 個節點和 2,646 個真實世界模板，使 Claude 能程式化地建構 n8n 工作流程。結合 **[czlonkowski/n8n-skills](https://github.com/czlonkowski/n8n-skills)**（7 個互補的 Claude Code skill），形成 Claude 可以修改自身自動化管線的自我改進系統。

### Webhook 路由參考

**[DeadBranches/n8n-Todoist-to-Notion](https://github.com/DeadBranches/n8n-Todoist-to-Notion)** 展示 webhook 鏈：Todoist webhook → n8n → HMAC 驗證 → 基於專案 ID 的路由 → 輸出至 Notion。這種基於專案的路由模式——不同 Todoist 專案觸發不同處理管線——直接對應 skill 路由。

-----

## 七、優化系統參考架構

綜合所有研究發現，最佳 daily-digest-prompt 架構結合了以下各專案的組件：

### 排程層

使用 **murmur 的 HEARTBEAT.md 模式**或 **agentuse 的 .agentuse 檔案**，將每日排程定義為版本控制的 Markdown。上午 9 點的 heartbeat 觸發摘要處理程序。加入 **claude-tasks 的使用量閾值**檢查，在 API 配額低於 20% 時阻止執行。

### 任務擷取層

透過**官方 Doist/todoist-ai MCP 伺服器**以 OAuth 連接 Todoist。使用 `findTasksByDate` 拉取今日任務。應用 **todoist-ai-assistant 的 TaskSense 管線**進行帶信心分數的優先級排名，確保最重要的任務優先執行。

### Skill 路由層

將 Todoist 標籤解析為 skill 識別符：

```
@code → code-generation/SKILL.md
@research → deep-research/SKILL.md
```

無標籤任務使用 LLM 語義路由（fast-agent 的 `@router` 模式）分類任務並選擇適當的 skill。遵循 **levnikolaevich 的協調器模式**，複雜任務自動委派給子 skill。

### 執行層

透過匹配的 skill 在 Claude Code 中執行每個任務。對多步驟任務使用 **obra/superpowers 的先規劃再執行**方法：腦力激盪 → 撰寫計劃 → 在隔離的 git worktree 中執行。應用 **Ralph Orchestrator 的反壓閘門**——任務持續迭代直到驗證通過（測試、lint、輸出驗證）。

### 完成層

成功時，透過 MCP 標記 Todoist 任務完成，將輸出成果（commit hash、檔案路徑、PR 連結）附為任務評論。失敗時，在任務中添加錯誤描述，降低優先級，延遲至下一個執行週期。使用 **sleepless-agent 的結果報告模式**將所有結果報告至 Slack。

-----

## 結論

daily-digest-prompt 的優化已不再是從零開始的問題。**Doist 官方的 todoist-ai MCP 伺服器**消除了整合摩擦，**obra/superpowers** 提供了大規模經過實戰檢驗的 skill 模式，**murmur** 和 **claude-tasks** 等排程器以 API 配額感知處理 cron 層。

**關鍵缺口**仍在「任務描述 → 自主工作完成 → 驗證」迴圈——沒有單一專案完整實現端到端流程。最接近的近似方案是 **TSK**（任務佇列 → Docker 沙箱 → git 分支）和 **Ralphy**（PRD → 平行代理執行 → 合併）。

建構完整管線需要結合：

- **todoist-ai-assistant** 的標籤路由
- **levnikolaevich/claude-code-skills** 的協調器 skill
- **Ralph Orchestrator** 的反壓驗證
- **murmur** 的排程守護程序

**每個組件都已存在；整合才是剩餘的工作。**